<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="bdLSZKDAikc4SOPIlDwwuSFBawDGQU3GmqUWTzUM-rE">
  <meta name="baidu-site-verification" content="codeva-lCWvLLHuj5">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3825645052664031"
     crossorigin="anonymous"></script>
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.iamlay.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"ordcer":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习任何一种语言，都有一个由表及里，由浅入深的过程。汇编是我们探究本质的终极大法，通过汇编，我们能从根本上了解现象背后的实质。本篇内容主要介绍了什么是汇编语言、寄存器及相关知识、汇编语言的一些简单指令、LLBD指令、并给出了一个简单的调试汇编的小例子。希望对iOS开发的同学有所帮助">
<meta property="og:type" content="article">
<meta property="og:title" content="以技术之名周报02#X86-汇编| 2020-04-05">
<meta property="og:url" content="https://www.iamlay.com/post/week14/index.html">
<meta property="og:site_name" content="以技术之名">
<meta property="og:description" content="学习任何一种语言，都有一个由表及里，由浅入深的过程。汇编是我们探究本质的终极大法，通过汇编，我们能从根本上了解现象背后的实质。本篇内容主要介绍了什么是汇编语言、寄存器及相关知识、汇编语言的一些简单指令、LLBD指令、并给出了一个简单的调试汇编的小例子。希望对iOS开发的同学有所帮助">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly01.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly02.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly03.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly04.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly05.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly06.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly07.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly08.png">
<meta property="og:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly09.png">
<meta property="article:published_time" content="2020-04-02T11:41:49.000Z">
<meta property="article:modified_time" content="2024-01-24T10:22:06.939Z">
<meta property="article:author" content="Ray">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly01.png">


<link rel="canonical" href="https://www.iamlay.com/post/week14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.iamlay.com/post/week14/","path":"post/week14/","title":"以技术之名周报02#X86-汇编| 2020-04-05"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>以技术之名周报02#X86-汇编| 2020-04-05 | 以技术之名</title>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-170943611-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-170943611-2');
</script>
  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?2fdaf8ee633a188c5649eefea79b28b3"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script async defer data-website-id="fad553b1-b94d-4311-8d52-913dc067e883" src="https://tongji.iamlay.com/script.js"></script><!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">以技术之名</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">以技术之名</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-chatgpt"><a href="/chatgpt" rel="section"><i class="fa fa-comment-dots fa-fw"></i>AI体验</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Part01-%E7%9F%A5%E8%AF%86%E5%87%86%E5%A4%87"><span class="nav-number">1.</span> <span class="nav-text">Part01 - 知识准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part02-%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9ALLVM"><span class="nav-number">2.</span> <span class="nav-text">Part02 - 编译器：LLVM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LLVM-%E7%9A%84%E7%BC%96%E8%AF%91%E6%9E%B6%E6%9E%84%E5%88%86%E4%B8%BA%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">2.1.</span> <span class="nav-text">LLVM 的编译架构分为三个阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LLVM-%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">LLVM 架构的优点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part03-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB%E5%8F%8A%E9%80%89%E6%8B%A9%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">Part03 - 汇编语言种类及选择：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">汇编语言种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9"><span class="nav-number">3.2.</span> <span class="nav-text">汇编语言选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part04-AT-amp-T%E6%B1%87%E7%BC%96"><span class="nav-number">4.</span> <span class="nav-text">Part04 - AT&amp;T汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">寄存器和数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">寻址模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-number">4.3.</span> <span class="nav-text">基础运算指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%92%8C%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">4.4.</span> <span class="nav-text">比较和跳转指令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">4.4.1.</span> <span class="nav-text">其他常用寄存器指令</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">4.5.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">4.6.</span> <span class="nav-text">函数调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part05-LLDB%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">Part05 - LLDB常用指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part06-Swift%E6%B1%87%E7%BC%96%E4%BE%8B%E5%AD%90"><span class="nav-number">6.</span> <span class="nav-text">Part06 - Swift汇编例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part07-%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">Part07 - 参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ray</p>
  <div class="site-description" itemprop="description">为信仰而生</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lhbWxheQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;iamlay"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjExODcwNzQ1NDNAcXEuY29t" title="E-Mail → mailto:1187074543@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.iamlay.com/post/week14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ray">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以技术之名">
      <meta itemprop="description" content="为信仰而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="以技术之名周报02#X86-汇编| 2020-04-05 | 以技术之名">
      <meta itemprop="description" content="学习任何一种语言，都有一个由表及里，由浅入深的过程。汇编是我们探究本质的终极大法，通过汇编，我们能从根本上了解现象背后的实质。本篇内容主要介绍了什么是汇编语言、寄存器及相关知识、汇编语言的一些简单指令、LLBD指令、并给出了一个简单的调试汇编的小例子。希望对iOS开发的同学有所帮助">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          以技术之名周报02#X86-汇编| 2020-04-05
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-02 19:41:49" itemprop="dateCreated datePublished" datetime="2020-04-02T19:41:49+08:00">2020-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-24 18:22:06" itemprop="dateModified" datetime="2024-01-24T18:22:06+08:00">2024-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%91%A8%E6%8A%A5/" itemprop="url" rel="index"><span itemprop="name">周报</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

	
            <div class="post-description">学习任何一种语言，都有一个由表及里，由浅入深的过程。汇编是我们探究本质的终极大法，通过汇编，我们能从根本上了解现象背后的实质。本篇内容主要介绍了什么是汇编语言、寄存器及相关知识、汇编语言的一些简单指令、LLBD指令、并给出了一个简单的调试汇编的小例子。希望对iOS开发的同学有所帮助</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h4 id="Part01-知识准备"><a href="#Part01-知识准备" class="headerlink" title="Part01 - 知识准备"></a>Part01 - 知识准备</h4><p>在介绍汇编之前，我们首先应该搞清楚什么是机器语言？什么是汇编语言？什么是高级语言？</p>
<p><strong>机器语言：</strong></p>
<blockquote>
<p>机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合。</p>
</blockquote>
<p><strong>汇编语言：</strong></p>
<blockquote>
<p>汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。汇编语言使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作。</p>
</blockquote>
<p><strong>高级语言:</strong></p>
<blockquote>
<p>高级编程语言是高度封装了的编程语言，与低级语言相对。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。比如：C、C++、Swift、Java…</p>
</blockquote>
<span id="more"></span>
<p>用一张图来解释这三种语言之间的关系：</p>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly01.png"></p>
<h4 id="Part02-编译器：LLVM"><a href="#Part02-编译器：LLVM" class="headerlink" title="Part02 - 编译器：LLVM"></a>Part02 - 编译器：LLVM</h4><p>汇编严重依赖硬件设备, <code>iOS</code>模拟器使用<code>AT&amp;T</code>格式汇编(因为 <code>Mac</code> 是基于 <code>Unix</code> 开发的), <code>iOS</code> 真机使用ARM汇编<br>。</p>
<p><code>Xcode</code>内置的编译器是<code>LLVM</code>，<code>LLVM</code> 是一个著名的编译器, 由大神 <code>Chris Lattner </code>开发, 可用于常规编译器, JIT编译器, 汇编器, 调试器, 静态分析工具等一系列跟编程语言相关的工作。</p>
<h5 id="LLVM-的编译架构分为三个阶段"><a href="#LLVM-的编译架构分为三个阶段" class="headerlink" title="LLVM 的编译架构分为三个阶段"></a>LLVM 的编译架构分为三个阶段</h5><ol>
<li>前端：进行语法分析, 语义分析, 生成中间代码。实际上在 Xcode 中写代码的时候会实时提示错误就是因为持续在调用 LLVM 的前端部分</li>
<li>公用优化器：将生成的中间文件进行优化, 去除冗余代码, 进行结构优化。</li>
<li>后端：将优化后的中间代码再次转换, 变为汇编语言, 再次进行优化. 最后将各个文件代码转换为二进制代码(机器语言)并链接以生成一个可执行文件。</li>
</ol>
<h5 id="LLVM-架构的优点"><a href="#LLVM-架构的优点" class="headerlink" title="LLVM 架构的优点"></a>LLVM 架构的优点</h5><ol>
<li>不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)</li>
<li>如果需要支持一种新的编程语言, 那么只需要实现一个新的前端(Swift 就是新增了一个针对于 Swift 的前端)</li>
<li>如果需要支持一种新的硬件设备, 那么只需要实现一个新的后端</li>
<li>优化阶段是一个通用的阶段, 它针对的是统一的LLVM IR, 不论是支持新的编程语言, 还是支持新的硬件设备, 都不需要对优化阶段做修改</li>
<li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族, Java, .NET, Python, Ruby, Scheme, Haskell, D等)</li>
</ol>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly02.png"></p>
<h4 id="Part03-汇编语言种类及选择："><a href="#Part03-汇编语言种类及选择：" class="headerlink" title="Part03 - 汇编语言种类及选择："></a>Part03 - 汇编语言种类及选择：</h4><h5 id="汇编语言种类"><a href="#汇编语言种类" class="headerlink" title="汇编语言种类"></a>汇编语言种类</h5><ol>
<li><code> AT&amp;T</code>格式(<code>UNIX</code>, <code>MAC</code>阵营):<code>8086</code>汇编(16bit 架构)<code>x64</code>汇编(64bit 架构)</li>
<li><code>Intel</code>格式(WIN阵营): <code>x86</code>汇编(32bit 架构)</li>
<li><code>ARM</code> 格式 (移动设备阵营): 只用在 <code>arm </code>处理器上</li>
</ol>
<h5 id="汇编语言选择"><a href="#汇编语言选择" class="headerlink" title="汇编语言选择"></a>汇编语言选择</h5><p>虽然不同的架构对应着不同的汇编语言，但是原理基本上是一样的，为了调试方便，我们将以X86-64架构来探究Swift中函数调用的本质。</p>
<h4 id="Part04-AT-amp-T汇编"><a href="#Part04-AT-amp-T汇编" class="headerlink" title="Part04 - AT&amp;T汇编"></a>Part04 - AT&amp;T汇编</h4><h5 id="寄存器和数据类型"><a href="#寄存器和数据类型" class="headerlink" title="寄存器和数据类型"></a>寄存器和数据类型</h5><p>X86-64有16个通用(几乎都是通用的)64位整数寄存器：</p>
<table>
<thead>
<tr>
<th>%rax</th>
<th>%rbx</th>
<th>%rcx</th>
<th>%rdx</th>
<th>%rsi</th>
<th>%rdi</th>
<th>%rbp</th>
<th>%rsp</th>
<th>%r8</th>
<th>%r9</th>
<th>%r10</th>
<th>%r11</th>
<th>%r12</th>
<th>%r13</th>
<th>%r14</th>
<th>%r15</th>
</tr>
</thead>
</table>
<p>因为早期处理器的不同寄存器的用途不同，并不是所有的指令都可以应用于每个寄存器。（现在基本上都是通用寄存器了）随着设计的发展，增加了新的指令和寻址模式，使各种寄存器几乎相等。除了几条特殊的指令，比如与字符串处理有关的指令，需要使用％rsi和％rdi，另外，还有两个寄存器保留用作堆栈指针（％rsp）和基址指针（％rbp）。最后的八个被编号的寄存器没有特别的限制。除此之外还有一个特殊的寄存器%rip(instruction pointer)，一般情况下你不需要关注这个寄存器,但是这个寄存器很重要，你需要知道他的功能，后面在说函数调用时会提及。</p>
<p>多年来X86架构已经从8位扩展到了32位，因此每个寄存器都有一些内部结构如下图：</p>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly03.png"></p>
<h5 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h5><p>什么是寻址模式？就是数据在内存寄和寄存器之间进行移动时，取得数据地址的不同表达方式。最常用的寻址的汇编指令是mov。x86-64使用的是复杂指令集(cisc)，因此mov有许多不同的变体，可以在不同单元之间移动不同类型的据。mov与大多数指令一样，具有单字母后缀，用于确定要移动的数据量。下表用于描述各种大小的数据值：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>全称</th>
<th>Size</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>byte</td>
<td>1byte(8 bits)</td>
</tr>
<tr>
<td>W</td>
<td>word</td>
<td>2byte(16 bits)</td>
</tr>
<tr>
<td>L</td>
<td>long</td>
<td>4byte(32 bits)</td>
</tr>
<tr>
<td>Q</td>
<td>quadword</td>
<td>8byte(64 bits)</td>
</tr>
</tbody></table>
<p><code>MOVB</code>移动一个字节，<code>MOVW</code>移动一个字，<code>MOVL</code>移动一个长整形，<code>MOVQ</code>移动一个四字。一般来说，<code>MOV</code>指令移动数据的大小必须与后缀匹配。虽然可以忽略后缀，汇编器将尝试根据参数选择合适的<code>MOV</code>指令。但是，不推荐这样做，因为它可能会造成预料之外的结果。</p>
<p>对于<code>AT&amp;T</code>语法使用<code>MOV</code>寻址时需要两个参数，第一个参数是<code>源地址</code>，第二个参数是<code>目标地址</code>。<code>原地址</code>的表达方式不一样那么寻址的方式也就不一样。比如，访问全局变量使用一个简单变量的名称比如<code>x</code>，我们称之为全局符号寻址。<code>printf</code>一个整数常量，由美元符号+数值表示(例如<code>$ 56</code>)，我们称之为直接寻址。访问寄存器的值直接使用寄存器的名字如  <code>%rbx</code>，我们称之为寄存器寻址。如果寄存器中存放的是一个地址，访问这个地址中的数据时需要在寄存器外面加上括号如<code>(%rbx)</code>，我们称之为间接寻址。如果寄存器中存放的是一个数组的地址，我们需要访问数组中的元素时可能需要操作这个地址进行偏移，如<code>8(％rcx）</code>是指<code>％rcx</code>中存放的的地址加<code>8</code>字节存储单元的值，我们称之为相对基址寻址（此模式对于操作堆栈，局部变量和函数参数非常重要）。在相对基址寻址上有各种复杂的变化，例如<code>-16（％rbx，％rcx，8</code>）是指地址<code>-16 +％rbx +％rcx * 8</code>处的值。此模式对于访问排列在数组中的特殊大小的元素非常有用。</p>
<p>以下是使用各种寻址模式将64位值加载到％rax的示例：</p>
<table>
<thead>
<tr>
<th>寻址模式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>全局符号寻址(Global Symbol)</td>
<td>MOVQ x, %rax</td>
</tr>
<tr>
<td>直接寻址(Immediate)</td>
<td>MOVQ $56, %rax</td>
</tr>
<tr>
<td>寄存器寻址(Register)</td>
<td>MOVQ %rbx, %rax</td>
</tr>
<tr>
<td>间接寻址(Indirect)</td>
<td>MOVQ (%rsp), %rax</td>
</tr>
<tr>
<td>相对基址寻址(Base-Relative)</td>
<td>MOVQ -8(%rbp), %rax</td>
</tr>
<tr>
<td>相对基址偏移缩放寻址(Offset-Scaled-Base-Relative)</td>
<td>MOVQ -16(%rbx,%rcx,8), %rax</td>
</tr>
</tbody></table>
<p>通常，可以使用相同的寻址模式将数据存储到寄存器和内存。但是，并不是所有模式都支持。比如不能对<code>MOV</code>的两个参数都使用<code>base-relative mode</code>。像<code>MOVQ -8（％rbx</code>），<code>-8（％rbx</code>）这样是不行的。要准确查看支持哪些寻址模式组合，您必须阅读相关指令的手册。</p>
<h5 id="基础运算指令"><a href="#基础运算指令" class="headerlink" title="基础运算指令"></a>基础运算指令</h5><p>编译器需要四个基本的算术指令： <code>ADD</code>, <code>SUB</code>, <code>IMUL</code>, 和<code>IDIV</code>(加减乘除)。<code>add</code>和<code>sub</code>有两个操作数：一个来源值和一个被操作数。例如，这条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq %rbx, %rax</span><br></pre></td></tr></table></figure>

<p>将<code>％rbx</code>添加到<code>％rax</code>，并将结果放在<code>％rax</code>中，覆盖之前可能存在的内容。这就要求你在使用寄存器时要小心。 例如，假设你想计算 <code>c = b *（b + a）</code>，其中a和b是全局整数。要做到这一点，你必须小心，在执行加法时不要覆盖b的值。这里有一个实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movq  a, %rax</span><br><span class="line">movq  b, %rbx</span><br><span class="line">addq  %rbx, %rax</span><br><span class="line">imulq %rbx</span><br><span class="line">movq  %rax, c</span><br></pre></td></tr></table></figure>
<p><code>imul</code>指令有点不太一样：它将其参数乘以<code>％rax</code>的内容，然后将结果的低64位放入<code>％rax</code>，将高64位放入<code>％rdx</code>。（将两个64位数字相乘会产生一个128位数字。）</p>
<p><code>idiv</code>指令和乘法指令差不多：它以一个128位整数值开始，其低64位位于<code>％rax</code>，高位64位位于<code>％rdx</code>中，并将其除以参数。<code>（CDQO</code>指令用于将<code>％rax</code>符号扩展为<code>％rdx</code>，以便正确处理负值。）商被放在<code>％rax</code>中，余数放在<code>％rdx</code>中。例如，除以5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq a,  %rax    # set the low 64 bits of the dividend</span><br><span class="line">cdqo             # sign-extend %rax into %rdx</span><br><span class="line">idivq $5 </span><br></pre></td></tr></table></figure>

<p>大多数语言中的求模指令只是利用<code>％rdx</code>中剩余的余数,指令<code>INC</code>和<code>DEC</code>分别递增和递减寄存器。例如，语句<code>a = ++ b</code>可以翻译为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq b, %rax</span><br><span class="line">incq %rax</span><br><span class="line">movq %rax, a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>布尔操作的工作方式非常类似：AND，OR，和XOR指令需要两个参数，而NOT指令只需要一个参数。像MOV指令一样，各种算术指令可以在各种寻址模式下工作。但是，您可能会发现使用MOV将值载入和载出寄存器是最方便的，然后仅使用寄存器来执行算术运算。</p>
<h5 id="比较和跳转指令"><a href="#比较和跳转指令" class="headerlink" title="比较和跳转指令"></a>比较和跳转指令</h5><p>使用<code>JMP</code>指令，我们可以创建一个简单的无限循环，使用<code>％eax</code>寄存器从零开始计数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">    incq %rax</span><br><span class="line">    jmp loop</span><br></pre></td></tr></table></figure>

<p>为了定义更有用的程序结构，如终止循环和<code>if-then</code>等语句，我们必须有一个可以改变程序流程的机制。在大多数汇编语言中，这些处理由两种不同的指令处理：比较和跳转。<br>所有的比较都是通过<code>CMP</code>指令完成的。<code>CMP</code>比较两个不同的寄存器，然后在内部<code>EFLAGS</code>寄存器中设置几个位，记录这些值是相同，更大还是更小。你不需要直接看<code>EFLAGS</code>寄存器的值。而是根据结果的不同来做适当的跳转：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>如果大于则跳转</td>
</tr>
<tr>
<td>jne</td>
<td>如果不等于则跳转</td>
</tr>
<tr>
<td>jl</td>
<td>如果小于则跳转</td>
</tr>
<tr>
<td>jle</td>
<td>如果小于等于则跳转</td>
</tr>
<tr>
<td>jg</td>
<td>如果大于则跳转</td>
</tr>
<tr>
<td>jge</td>
<td>如果大于等于则跳转</td>
</tr>
</tbody></table>
<p>举个例子，这里是一个循环来使<code>％rax</code>从0到5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        movq $0, %rax</span><br><span class="line">loop:</span><br><span class="line">        incq %rax</span><br><span class="line">        cmpq $5, %rax</span><br><span class="line">        jle  loop</span><br></pre></td></tr></table></figure>

<p>再举个例子，一个条件赋值：如果全局变量x&gt;&#x3D;0，那么全局变量y&#x3D;10，否则 y&#x3D;20：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        movq x, %rax</span><br><span class="line">        cmpq $0, %rax</span><br><span class="line">        jle  twenty</span><br><span class="line">ten:</span><br><span class="line">        movq $10, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">twenty:</span><br><span class="line">        movq $20, %rbx</span><br><span class="line">        jmp  done</span><br><span class="line">done:</span><br><span class="line">        movq %ebx, y</span><br></pre></td></tr></table></figure>

<p>跳转的参数是目标标签。这些标签在一个汇编文件中必须是唯一且私密的，除了包含在.globl内的标签 ，其他标签不能在文件外部看到，也就是不能在文件外调用。用c语言来说，一个普通的汇编标签是static的，而.globl标签是extern</p>
<h6 id="其他常用寄存器指令"><a href="#其他常用寄存器指令" class="headerlink" title="其他常用寄存器指令"></a>其他常用寄存器指令</h6><ul>
<li><code>leaq %rbp,%rax</code>: 内存赋值 <code>lea</code>, 将 <code>rbq</code> 的内存地址值赋给 <code>rax</code></li>
<li><code>xorl %eax, %eax</code>: 异或<code> xor</code>, 将 <code>eax </code>清 <code>0</code>, 自己异或自己</li>
<li><code>jmp 0x80001</code>: 跳转 <code>jmp</code>, 跳转到函数地址为 <code>0x80001</code> 的地址</li>
<li><code>jmp *(%rax)</code>: 间接跳转<code> *()</code>, <code>rax</code> 是个内存地址,<code>*(rax)</code>是拿到<code> rax</code> 地址里的值</li>
<li><code>callq 0x80001</code>: 函数调用<code> call</code>, 调用地址为<code> 0x80001</code> 的函数, 一般配合 <code>retq</code></li>
</ul>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>栈是一种辅助数据结构，主要用于记录程序的函数调用历史记录以及不适合寄存器的局部变量。栈从高地址向低地址增长。<code>％rsp</code>寄存器被称为<code>“栈指针”</code>并跟踪堆栈中最底层(也就是最新的)的数据。因此，要将<code>％rax</code>压入堆栈，我们必须从<code>％rsp</code>中减去<code>8（％rax</code>的大小，以字节为单位），然后写入<code>％rsp</code>指向的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8, %rsp</span><br><span class="line">movq %rax, (%rsp)</span><br></pre></td></tr></table></figure>

<p>从栈中弹出一个值与上面的操作相反：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp), %rax</span><br><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure>

<p>从栈中丢弃最新的值，只需移动堆栈指针即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure>

<p>当然，压栈(入栈)或出栈是经常使用到的操作，所以都有简化的单条指令，其行为与上面的完全一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rax</span><br><span class="line">popq  %rax</span><br></pre></td></tr></table></figure>


<h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>所有c标准库中可用的函数也可以在汇编语言程序中使用。以一种称为“调用约定”的标准方式调用，以便用多种语言编写的代码都可以链接在一起。<br>在x86 32位机器中。调用约定只是将每个参数入栈，然后调用该函数。被调用函数在栈中查找参数，完成它的工作之后，将结果存储到单个寄存器中。然后调用者弹出栈中的参数。<br>Linux上x86-64使用的调用约定有所不同，称之为System V ABI。完整的约定相当复杂，但以下是对我们来说足够简单的解释：</p>
<ul>
<li>整数参数（包括指针）按顺序放在寄存器％rdi，％rsi，％rdx，％rcx，％r8和％r9中。</li>
<li>浮点参数按顺序放置在寄存器％xmm0-％xmm7中。</li>
<li>超过可用寄存器的参数被压入栈。</li>
<li>如果函数使用可变数量的参数（如printf），那么必须将％eax寄存器设置为浮点参数的数量。</li>
<li>被调用的函数可以使用任何寄存器，但如果它们发生了变化，则必须恢复寄存器％rbx，％rbp，％rsp和％r12-％r15的值。</li>
<li>函数的返回值存储在％eax中。</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>用途</th>
<th>是否需要保存</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>保存返回结果</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rbx</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>参数4</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rdx</td>
<td>参数3</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rsi</td>
<td>参数2</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rdi</td>
<td>参数1</td>
<td>无需保存</td>
</tr>
<tr>
<td>%rbp</td>
<td>栈基址指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>栈指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r8</td>
<td>参数5</td>
<td>无需保存</td>
</tr>
<tr>
<td>%r9</td>
<td>参数6</td>
<td>无需保存</td>
</tr>
<tr>
<td>%r10</td>
<td>-</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>-</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>-</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<p>每个函数都需要使用一系列寄存器来执行计算。然而，当一个函数被另一个函数调用时会发生什么？我们不希望调用者当前使用的任何寄存器被调用的函数破坏。为了防止这种情况发生，每个函数必须保存并恢复它使用的所有寄存器，方法是先将它们入栈，然后在返回之前将它们从堆栈弹出。在函数调用的过程中，栈基址指针<code>%rbp</code>始终指向当前函数调用开始时栈的位置，栈指针<code>%rsp</code>始终指向栈中最新的元素对应的位置。<code>%rbp</code>和<code>%rsp</code>之间的元素被我们成为<code>&quot;栈帧&quot;</code>，也叫<code>&quot;活动记录&quot;</code>。函数的调用过程其实就是栈帧被创建，扩张然后被销毁的过程。在说明函数调用流程前，我们不得不提到<code> %rip(instruction pointer)</code> 指令指针寄存器。<code>%rip</code>中存放的是CPU需要执行的下一条指令的地址。每当执行完一条指令之后，这个寄存器会自动增加(可以这样理解)以便指向新的指令的地址。有了这些基础，接下来我们以一段完整的程序代码来解释函数的调用流程，有下面一段c代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x = sum(1, 2);</span><br><span class="line">    printf(&quot;result is:%d\n&quot;, x);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为汇编代码之后，为了方便读代码，我们去除一些不需要的指示段之后得到如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;main.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  sum</span><br><span class="line">    .type   sum, @function</span><br><span class="line">sum:</span><br><span class="line">.LFB0:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %edx</span><br><span class="line">    movl    -8(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   sum, .-sum</span><br><span class="line">    .section    .rodata</span><br><span class="line">.LC0:</span><br><span class="line">    .string &quot;result is:%d\n&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $2, %esi</span><br><span class="line">    movl    $1, %edi</span><br><span class="line">    call    sum</span><br><span class="line">    movl    %eax, -4(%rbp)</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道linux系统中<code>main</code>函数是由glibc中的 <code>exec()</code>簇 函数调用的，比如我们从shell环境中启动程序最终就是由 <code>execvp()</code>调用而来。我们这里不展开说明，你只需要知道<code>main</code>函数其实也是被调用的函数。我们从<code>main</code>函数的第一条指令开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br></pre></td></tr></table></figure>
<p>首先，将当前的栈基址指针%rbp入栈，函数调用结束后我们就可以从栈中取得函数调用前%rbp指向的位置，进而恢复栈到之前的样子。然后使当前栈指针指向新的位置。然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subq    $16, %rsp</span><br><span class="line">movl    $2, %esi</span><br><span class="line">movl    $1, %edi</span><br></pre></td></tr></table></figure>

<p>在栈上申请16字节的空间以便存放后面的临时变量x，然后根据System V ABI的调用约定将传递给sum函数的参数放入%esi和%edi中(因为是int类型占用4个字节，所以只需要用寄存器的低4字节即可)。这里你可能会发现编译器没有将需要调用者保存的%r10和%r11入栈，因为编译器知道在main函数中不会使用到%r10和%r11寄存器所以无需保存。然后发出调用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call sum</span><br></pre></td></tr></table></figure>
<p>需要注意以上的CALL指令等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rip</span><br><span class="line">jmp sum</span><br></pre></td></tr></table></figure>
<p>我们把<code>%rip</code>当前的内容放入栈中，以便函数<code>sum</code>调用结束我们可以知道接下来该执行哪条指令，我们假设栈从<code>0xC0000000</code>处开始向低处延伸。到这个阶段栈的变化过程如下所示：</p>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly04.png"></p>
<p>现在程序跳转到sum处执行计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">movl    %edi, -4(%rbp)</span><br><span class="line">movl    %esi, -8(%rbp)</span><br><span class="line">movl    -4(%rbp), %edx</span><br><span class="line">movl    -8(%rbp), %eax</span><br><span class="line">addl    %edx, %eax</span><br></pre></td></tr></table></figure>

<p>和<code>main</code>函数被调用一样，<code>sum</code>函数被调用时，首先也是保存<code>%rbp</code>，然后更新栈指针<code>%rsp</code>，将两个参数拷贝到栈中进行使用。在这里你可能看到了和<code>main</code> 函数不一样的地方，局部变量保存在栈中并没有像main函数中那样引起<code>%rsp</code>的移动(对比<code>main</code>函数中的<code>SUBQ 16</code>)。是因为编译器知道sum中不会再调用其它函数，也就不用保存数据到栈中了，直接使用栈空间即可。所以就无需位移<code>%rsp</code>。计算完成后结果保存在<code>%eax</code>中，现在我们更新一下栈的变化：</p>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly05.png"></p>
<p>然后返回到main函数时执行了如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popq    %rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>先恢复调用前的栈基址指针%rbp，然后此时栈顶的元素就是函数调用之后需要执行的下一条指令的地址，RET指令等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popq    %rip</span><br></pre></td></tr></table></figure>

<p>这样就可以跳转到函数结束后的下一条指令 “movl %eax, -4(%rbp)”处继续执行,至此我们看一下完整调用过程中栈的变化：</p>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly06.png"></p>
<p>更多关于寄存器的知识可以看<span class="exturl" data-url="aHR0cHM6Ly9uaWZlbmd6LmNvbS9pbnRyb2R1Y3Rpb25feDY0X2Fzc2VtYmx5Lw==">这篇博客<i class="fa fa-external-link-alt"></i></span>,讲的更加详细</p>
<h4 id="Part05-LLDB常用指令"><a href="#Part05-LLDB常用指令" class="headerlink" title="Part05 - LLDB常用指令"></a>Part05 - LLDB常用指令</h4><p>了解了汇编的基本指令时候，我们需要再了解在Xcode中如何使用LLDB指令来调试汇编代码</p>
<ul>
<li>读取寄存器的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">register read/ </span><br><span class="line">/*例*/POPQ  %rax</span><br><span class="line">register read/x rax    // 读取寄存器 rax 里面的值，/后面的参数为进制：x:16 进制,f: 浮点,d:10 进制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>修改寄存器的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">register write</span><br><span class="line">/*例*/</span><br><span class="line">register write rax 4 // 将rax修改为 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>读取内存中的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x/数量-格式-字节大小</span><br><span class="line"></span><br><span class="line">/*例*/</span><br><span class="line"></span><br><span class="line">x/4xg 0x1000002</span><br><span class="line">// 将 0x1000002 地址的值, 以 8 个字节的格式, 分成 4 份, 16 进制 展示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>修改内存中的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memory write 内存地址 数值</span><br><span class="line"></span><br><span class="line">/*例*/</span><br><span class="line"></span><br><span class="line">memory write  0x1000002 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 是十六进制，f是浮点，d是十进制，</span><br></pre></td></tr></table></figure>

<ul>
<li>字节大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b - byte 1 字节</span><br><span class="line">h - half word 2 字节</span><br><span class="line">w - word 4 字节</span><br><span class="line">g - giant word 8 字节</span><br></pre></td></tr></table></figure>

<ul>
<li>单步运行，把子函数当作一个整体，一步执行（源码级别）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-over、next、n</span><br></pre></td></tr></table></figure>
<ul>
<li>单步运行，遇到子函数会进入子函数(源码级别)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-in 、 step、s</span><br></pre></td></tr></table></figure>
<ul>
<li>单步运行，把子函数当作一个整体一步执行（汇编级别）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-inst-over 、 nexti、ni</span><br></pre></td></tr></table></figure>

<ul>
<li>单步运行，遇到子函数会进入子函数（汇编级别）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-inst 、 stepi、si</span><br></pre></td></tr></table></figure>
<ul>
<li>直接执行完当前函数的所有代码，返回上一个函数（遇到断点会卡住）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread step-out 、finish</span><br></pre></td></tr></table></figure>

<h4 id="Part06-Swift汇编例子"><a href="#Part06-Swift汇编例子" class="headerlink" title="Part06 - Swift汇编例子"></a>Part06 - Swift汇编例子</h4><ol>
<li>新建一个<code>Command Line Tool</code>工程，并在<code>main.swift</code>文件中新建一个<code>sum</code>函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func sum( a: Int, b: Int) -&gt; Int&#123;</span><br><span class="line">    return (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>Xcode</code>进入汇编调试模式，并在<code>main</code>函数中调用<code>sum</code>函数</li>
</ol>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly07.png"></p>
<p>3.在<code>main</code>函数中，调用<code>sum</code>函数，在调用<code>sum</code>函数地方打断点</p>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly08.png"></p>
<p>4.通过在控制台执行 <code>n</code>指令，可以定位到第11行,执行<code>si</code>指令可以进入<code>sum</code>函数，在<code>sum</code>函数中，我们可以看到最终通过<code>%rdx</code>和<code>%rcx</code>完成累加，并最终将值放如<code>%rax</code>寄存器，作为函数返回值</p>
<p><img src="https://testingcf.jsdelivr.net/gh/iamlay/BlogResources@main/imgs/week/Assembly09.png"></p>
<h4 id="Part07-参考"><a href="#Part07-参考" class="headerlink" title="Part07 - 参考"></a>Part07 - 参考</h4><p><span class="exturl" data-url="aHR0cHM6Ly9uaWZlbmd6LmNvbS9pbnRyb2R1Y3Rpb25feDY0X2Fzc2VtYmx5Lw==">x86-64汇编入门
<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oYW5sZXlsZWUuY29tL2NvbXBpbGUtb2YtaW9zLXByb2plY3QuaHRtbA==">iOS 之编译<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzMzOTE5MQ==">x86-64 下函数调用及栈帧原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGRmNjYzODUxODgyNTZlODU1YjZlMGM=">从 简单汇编基础 到 Swift 不简单的 a + 1<i class="fa fa-external-link-alt"></i></span></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Ray 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag"># 原创</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/week13/" rel="prev" title="以技术之名周报01#开篇| 2020-03-29">
                  <i class="fa fa-chevron-left"></i> 以技术之名周报01#开篇| 2020-03-29
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/week15/" rel="next" title="以技术之名周报03#AOP| 2020-04-12">
                  以技术之名周报03#AOP| 2020-04-12 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"iamlay","repo":"gitalk","client_id":"798848f6f91162435156","client_secret":"d9b621213c7353cfa8b2286491f877ef4507da1e","admin_user":"iamlay","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"545d41c0728988b9e21ed559789c9e34"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
